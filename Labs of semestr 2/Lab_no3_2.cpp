//УСЛОВИЕ ЗАДАЧИ:
//      Когда происходит печать документа, обычно первая страница печатается первой, вторая - второй, третья - третьей и так далее до конца.
//Но иногда при создании буклета на одном листе печатаются четыре страницы : две - на лицевой стороне и две - на обратной.
//Когда вы сложите все листы по порядку и согнете их пополам, страницы будут идти в правильном порядке, как у обычной книги.Например, 
//4 - страничный буклет должен быть напечатан на одном листе бумаги : лицевая сторона должна содержать сначала страницу 4, потом - 1, обратная - 2 и 3.
//Если в буклете число страниц не кратно четырем, то в конце можно добавить несколько пустых страниц, но так, 
//чтобы количество листов бумаги при этом было минимально возможным.
//Требуется написать программу, которая по заданному числу страниц в буклете генерирует порядок его печати.
//Входные данные
//      Во входном файле INPUT.TXT записано количество страниц в буклете - натуральное число, не превышающее 500.
//Выходные данные
//      В выходной файл OUTPUT.TXT необходимо выдать порядок печати данного буклета - последовательность команд, 
//каждая из которых располагается в отдельной строке и состоит из четырех чисел.Числа разделяются пробелом и обозначают следующее : 
//номер листа, на котором происходит печать, сторону : 1 - если печать происходит на лицевой стороне, и 2 - если на обратной,
//два оставшихся числа - номера страниц буклета, которые должны быть напечатаны с левой и правой сторон.
//Пустая страница задается числом 0. Если целая сторона должна быть оставлена пустой, команду для ее печати выводить не обязательно.

#include <iostream>
#include <fstream>
using namespace std;

void func1(int num, int** mat, int i ,int &l, int &r, int st)
{
    if (st == 0)// Порядок записи если это внешняя сторона листа 
    {
        mat[i][1] = 1;
        if (num >= r)
        {
            mat[i][2] = r;
            r--;
        }
        else
        {
            mat[i][2] = 0;
            r--;
        }
        if (num >= l)
        {
            mat[i][3] = l;
            l++;
        }
        else
        {
            mat[i][3] = 0;
            l++;
        }
    }
    if (st == 1)// Порядок записи если это внутренняя сторона листа 
    {   
        mat[i][1] = 2;
        if (num >= l)
        {
            mat[i][2] = l;
            l++;
        }
        else
        {
            mat[i][2] = 0;
            l++;
        }

        if (num >= r)
        {
            mat[i][3] = r;
            r--;
        }
        else
        {
            mat[i][3] = 0;
            r--;
        }
    }
}
int main()
{
    setlocale(LC_ALL, "ru");
    int num , list;// num- в буклете должнo быть столько страниц  , list-мин. количество листов которые нам потребуются 
    ifstream fin("INPUT.TXT");
    if (!fin.is_open())
    {
        cout << "Не смогли открыт файл INPUT.TXT";
        return 0;
    }
    fin >> num;
    fin.close();

    list = num / 4;
    if (num % 4 != 0)
        list++;
    int l = 1, r = list * 4; // l-текущая страница ,r-последняя страница 
    int k = 0, s = 0; //k- переменная для уточнения стороны листа ( т.е. внутренняя/ внешняя) , s-это номер листа
    int stranic = list * 2;//Количество страниц
 
    int** mat = new int* [stranic];   // Матрица для записи результата
    for (int i = 0; i < 2 * list; i++)
        mat[i] = new int[4];
    ////////////////////
  
    for (int i = 0; i < stranic; i++)
    {
        if (i% 2 == 0)
        {
            s++;
            mat[i][0] = s;
        }
        else
        {
            mat[i][0] = s;
        }
        k %= 2;
        func1(num, mat, i, l, r, k);
        k++;
    }
    //Запись результата в файл
    ofstream fout("OUTPUT.TXT");
    if (!fout.is_open())
    {
        cout << "error";
        return 0;
    }
    for (int i = 0; i< stranic; i++)
    {
        for (int j = 0; j < 4; j++)
        {
            cout << mat[i][j] << " ";
            fout << mat[i][j] << " ";
        }
        fout << endl;
        cout << endl;
    }
    fout.close();

    ///Освобождение памяти 
    for (int i = 0; i < 2 * list; i++)
        delete[] mat[i];
    delete[]mat;
    mat = nullptr;
}
